package algorithm

import (
	"fmt"
	"testing"
)

// 冒泡排序
//
// 初始状态:
//
// [24, 69, 80, 57, 13]
//
// 第1轮排序:
//
// 第1次比较: [24, 69, 80, 57, 13]
// 第2次比较: [24, 69, 80, 57, 13]
// 第3次比较: [24, 69, 57, 80, 13]
// 第4次比较: [24, 69, 57, 13, 80]
//
// 第2轮排序:
//
// 第1次比较: [24, 69, 57, 13, 80]
// 第2次比较: [24, 57, 69, 13, 80]
// 第3次比较: [24, 57, 13, 69, 80]
//
// 第3轮排序:
//
// 第1次比较: [24, 57, 13, 69, 80]
// 第2次比较: [24, 13, 57, 69, 13]
//
// 第4轮排序:
//
// 第1次比较: [13, 24, 57, 69, 80]
//
// 分析:
// 1. 共进行4轮排序，由此得出外层循环次数为len(arr) - 1
// 2. 每轮排序确定一个数的位置，越往后单轮排序内的比较次数越少，由此判断内层循环次数根据外层循环次数递减
// 3. 每次都要比较本次循环到的元素和后一位元素的大小，依据情况判断是否交换
func bubbleSort(data []int) {
	// 外层循环控制行（共排序len(data) - 1次，每次循环在尾部确定一个数据的最终位置）
	for i := 0; i < len(data)-1; i++ {
		// 内层循环控制列（-i的原因是序列尾部有序的数据的数量会随着外层循环的次数增加而增加）
		for j := 0; j < len(data)-1-i; j++ {
			// 相邻元素做比较
			if data[j] > data[j+1] {
				// 符合规则就替换
				data[j], data[j+1] = data[j+1], data[j]
			}
		}
	}
}

// 冒泡排序
func TestBubbleSort(t *testing.T) {
	data := []int{4, 2, 8, 0, 5, 7, 1, 3, 9}
	bubbleSort(data)
	fmt.Println(data)
}
